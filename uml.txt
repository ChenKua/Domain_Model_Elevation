class SHAS
{
	1 <@>- 1..* Room rooms;
	1 <@>- 1 ActivityLog log;
	1 <@>- * AutomationRule allRules;
	// subset of allRules
	1 -> * AutomationRule activeRules;
	// When editing rules, can only retrieve from this set
	// subset of allRules but intersection with activerules = null
	1 -> * AutomationRule inactiveRules; 
}

class ActivityLog
{
	// Maybe composition with SHAS and simple association here?
	1 <@>- * SensorReading sensorReadings;
	1 <@>- * ActuatorCommand commands;
}

// This abstract interface is used for all physical elements of the SHAS
// so that they can be easily referred to by the automation rules as "Elements" of the SHAS.
class Element
{
}

class Room
{
	isA Element;
	1 <@>- * Device devices;
}

class Device
{
	isA Element;
	autounique identifier;
	Boolean isActive;
}

class Sensor
{
	isA Device;
	enum SensorType { Temperature, Movement };
	SensorType type;
	
	1 -- * SensorReading readings;
}

class SensorReading
{
	isA Element;
	Double reading;
	Time timestamp;
	String readingType;
}

class Actuator
{
	isA Device;
	enum ActuatorType { Light, Lock };
	ActuatorType type;
	
	1 -- * ActuatorCommand commands;
}

class ActuatorCommand
{
	isA Element;
	enum CommandType { LockDoor, TurnOnHeating, TurnOnLights };
	CommandType type;
	Time timestamp;
	enum CommandStatus { Requested, Completed, Failed };
	CommandStatus status;
}

// Dealing with the automation rules:

class AtomicTerm
{
	String expression;
	1 -- 1..* Element refersTo;
	Boolean atomicValue;
}

class Relation
{
	enum Operator { AND, OR, NOT};
	Operator op;
	1 -> 1 AtomicTerm LHS;
	// 0..1 in case of NOT, this should be ignored
	1 -> 0..1 AtomicTerm RHS;
	Boolean value;
}

class Precondition
{
	1 -> 1..* Relation relations;
	
	// Some parser will parse the relations (and atomic terms) and determine the final value of the precondition
	Boolean value;
}

class AutomationRule
{
	// Use a separate instance of a precondition for each automationrule.
	1 -- 1 Precondition precondition;
	1 -- * ActuatorCommand actionSequence;
	Boolean isActive;
	
	1 -> * AutomationRule dependsOn;
	1 -> * AutomationRule conflictsWith;
	
	// "SHAS records whenever a rule was triggered using a timestamp"
	Time[] activations;
}
